#!/usr/bin/env python3

"""
Generates C++ header and source files containing precomputed lookup tables 
for 7-card poker hand evaluation using the TwoPlusTwo algorithm data.

Reads the C arrays directly from the tangentforks/TwoPlusTwoHandEvaluator 
repository (expected to be cloned at 'external/2p2') specifically from 'arrays.h'.

Source Credit: tangentforks/TwoPlusTwoHandEvaluator (Public Domain)
Based on work by Kevin Suffecool.

Usage:
  python tools/gen_lookup_tables.py \
    --repo-path external/2p2 \
    --header ${CMAKE_CURRENT_BINARY_DIR}/lookup_tables.hpp \
    --source ${CMAKE_CURRENT_BINARY_DIR}/lookup_tables.cpp 
"""

import argparse
import os
import time
import re
import sys

# --- Configuration ---
# Mapping from our desired C++ name to the C array name in the source repo
# Based on tangentforks/TwoPlusTwoHandEvaluator/arrays.h:
TABLE_NAME_MAP = {
    "HASH_ADJUST": "FlushCheck", # Array name in arrays.h
    "RANKS": "HandRanks",         # Array name in arrays.h
}
TABLE_DATA_TYPE = "uint16_t" # Data type for the C++ arrays
C_SOURCE_FILENAME = "arrays.h" # File containing the array definitions

OUTPUT_HEADER_TEMPLATE = """\
// Generated by tools/gen_lookup_tables.py on {{generation_date}}
// Data sourced from tangentforks/TwoPlusTwoHandEvaluator repository (Public Domain) / {{c_source_filename}}
// Based on work by Kevin Suffecool.
// DO NOT EDIT MANUALLY!

#ifndef GTO_SOLVER_EVAL_GENERATED_LOOKUP_TABLES_HPP
#define GTO_SOLVER_EVAL_GENERATED_LOOKUP_TABLES_HPP

#include <cstdint>
#include <cstddef> // For std::size
#include <array>   

namespace gto::eval::tables {{

// Alias for the rank type used in tables (lower is better, 1=RoyalFlush)
using HandRank = {data_type}; 

// --- Lookup Tables (Extern Const Declaration) ---

// Maps a hash derived from 7 cards (primarily non-flush properties)
// to a rank adjustment or intermediate value. (Source: FlushCheck)
extern const {data_type} HASH_ADJUST[{hash_adjust_size}];

// Maps a final hash (adjusted for flushes/straights) to the hand rank (1-4888).
// (Source: HandRanks)
extern const HandRank RANKS[{ranks_table_size}];

// --- Table Size Checks (using actual parsed sizes) ---
// Use std::size for C++17 compatibility with C arrays
static_assert(sizeof(HASH_ADJUST)/sizeof(HASH_ADJUST[0]) == {hash_adjust_size}, "HASH_ADJUST size mismatch (expected from {c_source_filename})");
static_assert(sizeof(RANKS)/sizeof(RANKS[0]) == {ranks_table_size}, "RANKS size mismatch (expected from {c_source_filename})");

}} // namespace gto::eval::tables

#endif // GTO_SOLVER_EVAL_GENERATED_LOOKUP_TABLES_HPP
"""

OUTPUT_SOURCE_TEMPLATE = """\
// Generated by tools/gen_lookup_tables.py on {{generation_date}}
// Data sourced from tangentforks/TwoPlusTwoHandEvaluator repository (Public Domain) / {{c_source_filename}}
// Based on work by Kevin Suffecool.
// DO NOT EDIT MANUALLY!

#include "lookup_tables.hpp" // Include the generated header

namespace gto::eval::tables {{

// --- Lookup Tables (Const Definition) ---

// Source: FlushCheck from {c_source_filename}
constexpr const {data_type} HASH_ADJUST[{hash_adjust_size}] = {{
{hash_adjust_data}
}};

// Source: HandRanks from {c_source_filename}
constexpr const HandRank RANKS[{ranks_table_size}] = {{
{ranks_table_data}
}};

}} // namespace gto::eval::tables
"""

# --- C Code Parsing Logic ---

def extract_c_array_data(c_source_content, array_name):
    """Extracts numerical data from a C array definition in arrays.h format."""
    # Regex for arrays.h format: e.g., static unsigned short HandRanks[4888] = { ... };
    # Handles optional static/unsigned/short/int keywords and potential size in brackets.
    regex = re.compile(
        r"(?:static\s+|const\s+|unsigned\s+|short\s+|int\s+)*" # Optional type keywords
        r"%s\s*" # Array name
        r"(?:\s*\[\s*\d*\s*\])?\s*" # Optional size in brackets
        r"=\s*\{\s*([^}]*)\s*\};" # Content inside curly braces
        % re.escape(array_name),
        re.MULTILINE | re.DOTALL
    )
    match = regex.search(c_source_content)
    
    if not match:
        print(f"Error: Could not find C array definition for '{array_name}' in provided content.", file=sys.stderr)
        # Print first few lines for debugging regex issues
        # print("--- Start of content searched ---")
        # print(c_source_content[:500])
        # print("--- End of content searched ---")
        return None

    content = match.group(1) # Content is the first captured group (inside {})
    
    # Remove C comments (might not be present, but safe to keep)
    content = re.sub(r"/\*.*?\*/", "", content, flags=re.DOTALL)
    content = re.sub(r"//.*", "", content)
    
    # Split by comma and strip whitespace, filter out empty strings
    data = [item.strip() for item in content.split(',') if item.strip()]
    
    # Convert to integers
    try:
        # Use int(val, 0) to handle potential hex values (like 0x...) if they exist
        int_data = [int(val, 0) for val in data] 
        return int_data
    except ValueError as e:
        print(f"Error: Could not parse value in array '{array_name}': {e}", file=sys.stderr)
        # Find the problematic value
        problem_val = "?"
        for val in data:
             try: int(val, 0)
             except ValueError: problem_val = val; break
        print(f"Problematic value: '{problem_val}'", file=sys.stderr) 
        print(f"Problematic content snippet: '{content[:200]}...'", file=sys.stderr)
        return None

def format_table_data(data, values_per_line=12):
    """Formats table data into a C++ array initializer string."""
    lines = []
    count = len(data)
    for i in range(0, count, values_per_line):
        line_data = data[i:min(i + values_per_line, count)]
        str_line_data = [str(item) for item in line_data] 
        lines.append("  " + ", ".join(str_line_data) + ("," if i + values_per_line < count else ""))
    return "\n".join(lines)

# --- Main Execution ---

def main():
    parser = argparse.ArgumentParser(description="Generate C++ lookup tables from TwoPlusTwo C source (arrays.h).")
    parser.add_argument("--repo-path", required=True, help="Path to the cloned tangentforks/TwoPlusTwoHandEvaluator repository.")
    parser.add_argument("--header", required=True, help="Path to the output C++ header file.")
    parser.add_argument("--source", required=True, help="Path to the output C++ source file.")
    args = parser.parse_args()

    start_time = time.time()

    # Construct path to the C source file (arrays.h)
    c_source_path = os.path.join(args.repo_path, C_SOURCE_FILENAME)

    # Read the C source file
    try:
        with open(c_source_path, 'r') as f:
            c_source_content = f.read()
    except IOError as e:
        print(f"Error reading C source file: {e}", file=sys.stderr)
        print(f" Searched path: {c_source_path}", file=sys.stderr)
        exit(1)

    # Extract data for each required table
    extracted_data = {}
    table_sizes = {}
    all_ok = True
    for cpp_name, c_name in TABLE_NAME_MAP.items():
        print(f"Extracting data for {cpp_name} (from C array {c_name} in {C_SOURCE_FILENAME})...")
        data = extract_c_array_data(c_source_content, c_name)

        if data is None:
            print(f"Failed to extract data for {c_name}. Check C source file and TABLE_NAME_MAP.", file=sys.stderr)
            all_ok = False
            continue
            
        extracted_data[cpp_name] = data
        table_sizes[cpp_name] = len(data)
        print(f" -> Found {table_sizes[cpp_name]} elements.")

    if not all_ok:
        print("Errors occurred during C data extraction. Exiting.", file=sys.stderr)
        exit(1)
        
    # Format data for C++ output
    generation_date = time.strftime("%Y-%m-%d %H:%M:%S %Z")
    
    formatted_data_str = {}
    for name, data in extracted_data.items():
         formatted_data_str[name] = format_table_data(data)

    # Create header content
    header_content = OUTPUT_HEADER_TEMPLATE.format(
        generation_date=generation_date,
        data_type=TABLE_DATA_TYPE,
        c_source_filename=C_SOURCE_FILENAME,
        hash_adjust_size=table_sizes["HASH_ADJUST"],
        ranks_table_size=table_sizes["RANKS"]
    )

    # Create source content
    source_content = OUTPUT_SOURCE_TEMPLATE.format(
        generation_date=generation_date,
        data_type=TABLE_DATA_TYPE,
        c_source_filename=C_SOURCE_FILENAME,
        hash_adjust_size=table_sizes["HASH_ADJUST"],
        hash_adjust_data=formatted_data_str["HASH_ADJUST"],
        ranks_table_size=table_sizes["RANKS"],
        ranks_table_data=formatted_data_str["RANKS"]
    )

    # --- Write Files ---
    for path, content in [(args.header, header_content), (args.source, source_content)]:
        output_dir = os.path.dirname(path)
        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
        try:
            # Write only if content changed to avoid unnecessary recompiles
            existing_content = ""
            if os.path.exists(path):
                 with open(path, 'r') as f_read:
                     existing_content = f_read.read()
            
            if content != existing_content:
                 with open(path, 'w') as f:
                     f.write(content)
                 print(f"Successfully generated/updated file: {path}")
            else:
                 print(f"File content unchanged, skipping write: {path}")

        except IOError as e:
            print(f"Error writing file {path}: {e}", file=sys.stderr)
            exit(1)

    end_time = time.time()
    print(f"Table generation finished in {end_time - start_time:.2f} seconds.")

if __name__ == "__main__":
    main() 